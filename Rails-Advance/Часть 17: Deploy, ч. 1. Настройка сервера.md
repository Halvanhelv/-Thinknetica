

Заранее создаем сервер у арендатора серверов

Что бы подключится по ```ssh``` набираем 

```
ssh root@127.0.0.1
```

Пароль для ```root``` пользователя лучше делать через генератор паролей что бы был сложным

лучше для деплоя и других операций создать отдельного пользователя что бы не делится паролем для root пользователя

```bash
adduser deployer
```

 и сгенерировать пароль для юзера(он запросит пароль новый)

и дать права супер администратора что бы могли ставить разные пакеты с помощью

```
 sudo
```

вводим 

```bash
visudo
```

 под комментарием # User privilege specification

```
deploy ALL=(ALL:ALL) ALL
```

разница между ```root``` и ```deploy``` юзерами будет в том что для root юзера не требуется вводить ```sudo``` перед командой и можно случайно удалить что то или сломать а  для ```deploy``` нужно вводить ```sudo``` то юзер понимает что делает 

нужно настроить ssh, он используется стандартно 22 port и лучше сменить что бы ботам было сложнее достучаться до сервера где уже не стандартный порт

Нужно открыть конфиг ssh

```bash
nano /etc/ssh/sshd_config/
```

```#Port 22``` нужно раскомментировать и сменить порт на какой нибудь другой

```bash
Port 2222
```

```bash
Ctrl + O сохранить
Enter подтвердить имя файла
Ctrl + X выйти
```

перезапускам ssh

```bash
service ssh restart
```

убедимся что порт сменился с помощью команды:

```bash
service ssh status
```

подключаемся под новым юзером deployer

```bash
ssh deployer@127.0.0.1
```

у нас запросят пароль

настраиваем беспарольный доступ через ssh ключи

создаем на удаленном сервере папку

```bash
mkdir ~/.ssh
```



на локальном сервере создадим ```ssh``` ключи если вы их раньше не создавали, к примеру для ```ssh``` доступа на github

```bash
ssh keygen -t rsa 4096 -C "email@example.com"
```

идем в папку

```bash
cd ~/.ssh
```

находим файл

 ```bash
id_dsa.pub
 ```

выполняем команду которая перекинет публичный ключ на удаленный сервер в папку ```/.ssh```

такую команду пишем что бы не создавать вручную файл ```authorized_keys``` который хранит ```ssh``` ключи машин  у которых есть доступ к этому удаленному серверу

```bash
cat ~/.ssh/id_rsa | ssh -p 2222 deployer@128.199.55.204 'cat >> /home/deployer/.ssh/authorized_keys' 
```

```bash
[команда cat]
```

на удаленном сервере появился файл 

```bash
/home/deployer/.ssh/authorized_keys
```

Если теперь выйти из удаленного и войти то пароль уже не будет требоваться для входа на удаленную машину

Входим на удаленный сервер

обновляем все пакеты:

```bash
sudo apt update
```

устанавливаем их:

```bash
sudo apt update
```

перезагружаем удаленный сервер

```bash
sudo reboot
```

Теперь нужно настроить ```TimeZone``` (время в системе)

по умолчанию стоит ```UTC``` а ставим местное или то где живут большинство пользователей нашего сайта, команда покажет текущий ```TimeZone```:

```bash
data
```

меняем к примеру на Москву:

```bash
sudo dpkg-reconfigure tzdata
```

и проверяем что стоит Москва в помощью ```data```

Ставим ```Ruby```

лучше ставить через менеджер ```rvm``` так как он удобнее и можно ставить разные версии ```ruby``` а если ставить через ```apt get install ruby``` то будет не так удобно и не так часто обновляется репозиторий

[Установка ```rvm```]

что бы ```rvm``` заработал нужно перезапустить машину или ввести:

```
source /home/deployer/.rvm/scripts/rvm
```

Проверяем что все установилось и работает:

```bash
	rvm list
```

 Должен появится список доступных версий ```ruby```

далее ставим системные зависимости для установки и компиляции ```ruby```

```bash
rvm requirements
```

и ставим нужную версию  ```ruby```:

```bash
rvm install 2.6.0 
```

делаем установленный ```ruby``` по умолчанию:

```bash
rvm use 2.6.0 --default
```

Проверяем версию ```ruby```

```bash
ruby -v
```

Теперь нужно поставить базу данных ```postgres```

```bash
sudo apt install postgres
```

и нужно поставить специальные пакеты что бы гем ```pg``` правильно скомпилировался 

```bash
sudo apt install postgres-server-dev-"номер версии postgres без кавычек"
```

теперь нужно настроить ```postgres```

Дело в том что когда мы установили ```postgres``` у нас автоматически создалось два пользователя с одинаковым именем ***postgres***

Один системный такой же как ```root```, ```deployer``` то есть на уровне ```Linux```

Второй внутри базы данных и нужно для юзера базы данных сменить пароль что бы мы его знали, выполняем команду:

```bash
sudo -u postgres psql
```

```-u``` означает от имени какого пользователя ```linux``` мы выполняем команду ```psql``` консольный клиент ```postgres```

в ```psql``` выполняем:

```sql
ALTER USER postgres WITH PASSWORD 'пароль вместе с ковычками';
```

```\q``` выйти из ```psql```  в команде выше после ```USER``` указываем нужного юзера базы данных

Теперь нужно поставить прокси сервер ```nginx``` и ```application server``` 

Ставим ```nginx```

```bash
sudo apt install nginx
```

Проверим что он работает 

```bash
sudo service nginx status
```

 Если мы зайдем через браузер на наш ```ip``` адрес то увидим приветственную страницу ```nginx```

![Приветствие][Welcome to Nginx]

теперь ставим ```apllication server passenger```

[Установка ```Passenger```]

Посмотрим главный конфиг ```nginx```

```bash
sudo nano /etc/nginx/nginx.conf
```

Это глобальный конфиг он включается в себя основные настройки nginx

под комментарием ```#Virtual Host Configs``` будут строчки которые будут подключаться индивидуальные конфиги наших разных сайтов в главный конфиг и они хранятся как бы модульно

выходим и смотрит файл 

```bash
sudo /etc/nginx/conf.d/mod-http-passenger.conf
```

там будет две строки ```passenger_root``` и ```passenger_ruby``` где указано путь в ```passenger``` и к ```ruby``` эти пути могут совпадать а могут и не совпадать с реальными путями где расположены ```passenger``` и  ```ruby``` 

и нужно точно это указать что бы быть уверенными

путь для ```ruby``` узнаем командой:

```bash
which ruby
```

путь для ```passenger``` узнаем командой:

```bash
passenger-config --root
```

снова открываем конфиг и записываем правильные пути и сохраняем:

```bash
sudo /etc/nginx/conf.d/mod-http-passenger.conf
```

Теперь проверим что конфиг синтаксически правильно написан:

```bash
sudo service nginx configtest
```

И делаем рестарт для ```nginx``` что бы изменения конфига применялись

```bash
sudo service nginx restart
```

Теперь нужно настроить раздел сервер и конфиг для нашего конкретного сайта

создаем новый файл:

```bash
sudo nano /etc/nginx/sites-enabled/qna.conf
```

пишем в файле:

```bash
server {
listen 80;     #для ipV4
listen [::]80; #для ipV6

server_name 127.0.0.1; # указываем или имя хоста или ip если хоста нет
root /home/deployer/qna/current/public # в папку qna ставится приложение(указываем для capistrano) в current будет хранится текущая #версия приложения  а папка public считается корневой для веб серверов по типу nginx

passenger_enables on; # указываем что работает passenger

location ^~ /assets/ { # если в пути по которому обращается наш клиент есть assets
               gzip_static on; # то для таких путей включаем сжатие gzip-ом
               expires max; # время кеширования ставим максимальное 
               add_header Chache-Control public; # специальный заголовок указывающий браузеру как кешировать
}
}
```

и снова проверяем конфиг на наличие синтаксических ошибок:

```bash
sudo service nginx configtest
```

Перезапускам

```bash
sudo service nginx restart
```

Теперь если зайти через браузер то должны увидеть ошибку ```404```

Это значит что тот путь что мы указали в конфиге ```nginx``` указывает на приложение которого еще нет(```/home/deployer/qna/current/public```)

Теперь нужно поставить ```redis``` для нашего приложения

```bash
sudo apt install redis
```

У ```redis``` есть конфиг который ставится с пакетом но он не загружается по умолчанию, лежит он по пути

```bash
/etc/redis/
```

но что бы он загружался по умолчанию нужно выполнить команду а именно скопировать этот конфиг в ту же папку но добавить ```.default``` в конец названия :

```bash
sudo cp /etc/redis/redis.conf /etc/redis/redis.conf.default
```

Именно копируем а не переименовываем что бы оригинал остался как образец, перезагружаем ```redis``` что бы конфиг подтянулся

```bash
sudo service redis-server restart
```

и проверяем что все работает через:

```bash
sudo service redis-server status
```

Теперь нужно поставить ```Sphinx```

```bash
sudo apt install sphinxsearch
```

На этом в принципе настройка сервера завершена, нужно еще разобраться с отправкой почты, в реальных проектах это делается через сервисы к примеру [SendGrid], там даже есть бесплатные тарифы но он требует наличия домена но к плюсу относится более надёжная доставка сообщений и можно настроить определенные записи, ```DNS```  записи в домене таким образом чтобы почтовые клиенты не воспринимали наше сообщение как спам но нам будет достаточно отправки через gmail, это настраивается на уровне приложения ```Rails``` приложения, мы такое уже делали.

На этом базовая настройка завершена.



[Установка ```rvm```]:   https://rvm.io/
[команда cat]: https://losst.ru/komanda-cat-linux

[Welcome to Nginx]: https://i.imgur.com/QWttGis.png
[Установка ```Passenger```]: https://www.phusionpassenger.com/docs/advanced_guides/install_and_upgrade/nginx/install/oss/focal.html
[SendGrid]: https://sendgrid.com/