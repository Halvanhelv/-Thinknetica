3 правила оптимизации

1) измерять, измерять, измерять, то есть не стоит оптимизировать то что мы не измерили, и нужно оптимизировать именно то что медленно работает и желательно делать оптимизацию которая напрямую влияет на успешный опыт конечного пользователя, если это какая то внутренняя оптимизация которая мало сказывается на производительность системы с точки зрения пользователя то такую оптимизацию стоит проводить но она будет менее приоритетной 
под пользователем может подрузамеваться не всегда напрямую человек, возможно этот человек пользуется мобильным приложением  а ваша система это просто back end для мобильного приложения, то тогда прямым пользователем явлется мобильное приложение а апосредованным непосредственно человек и поэтому тут могут быть другого рода оптимизации

Что можно оптимизировать?

можно разбить вещи которые можно оптимизировать на 3 слоя

1. Back-end
   1.1 КОД
   1.2 Запросы к БД(N + 1, сложные запросы, большое количество запросов, индексы)
   1.3 Выносить задачи в очередь(Active job и Sidekiq)
   1.4 Использовать Redis и memchached

2. Server
   2.1 Память(Добавить памяти, экономичнее расходовать, более гибко настроить потребление памяти различных систем к примеру postgres, redis и тд)

   2.2 Диски(Например установить ssd это позволяет увеличить скорость работы система но конечно не всей так как часть системы работает в ОЗУ, быстрые диски подойдут для быстрой отдачи файлов, для загрузки и для быстрого кэширования файлов) 

   2.3 Load Balancing(Если у нас недостаточно серверов которые обрабатывают запросы и запросы встают в очередь то логично добавлять еще железо, иногда это наименее затратный и наиболее быстрый способ повысить производительность системы конечно если другие части работают более менее в рамках каких то ожиданий, то есть не очень медленно, конечно если у вас система тормозит из за к примеру базы данных то простым добавлением серверов вы не избавитесь от этой проблемы, если у вас более менее сбалансированная система то можно просто добавить еще один сервер)

3. Front-end
   3.1 JS оптимизация, и сжатие js - это что Rails теперь делает по умолчанию

   3.2 Assets(CDN, сжатие), вынос ассетов по типу, css, js, картинок на CDN(сеть которая раздает файлы с наиболее близкого для пользователя сервера)

   3.3  Кэширование(относится и к back-end и к front-end это тема размазана между этими двумя слоями)

​       3.4 Ajax(Визуальное ускорение для пользователя, то есть увеличение скорости отклика  системы, то же своего рода оптимизация так как с точки                                      зрения пользователя система стала более отзывчивая и приятнее работать)

И не нужно делать преждевременных оптимизаций, это правило справедливо почти всегда так как во время разработки в 90% случаях вы не можете знать или предположить где у вас будет(bottleneck(бутылочное горлышко)), самое узкое место системы,  то есть оптимизировать заранее не имеет смысла пока у вас нет четких данных на руках, ну к примеру есть в коде мелкие оптимизации которые не скажутся на скорости реакции системы но с точки зрения правил хорошего кода это должно быть, к примеру такие вещи как кэширование переменных (```@var =|| Question.new``` или использование метода map для преобразование массива), то есть оптимальные пути решения задач известных, то есть по сути это не является оптимизацией а просто нормальным, хорошим кодом, это просто хорошая практика, это сложно назвать оптимизацией так как оптимизацией называется то что значительно влияет на скорость системы

Очень часто в разработке вы можете увидеть в логе что у вас идет большое количество запросов, это уже тоже сигнал что это можно оптимизировать, это может быть значительно не отразится на поведении системы но это явно знак что нужно на это обратить внимание и как то это решить, либо использовать жадную загрузку или еще какими то способами, одним sql запросом сделать вызов всего что необходимо итд, такой метод оптимизации прямо во время разработки допустим так как это нормальный подход к решению задач оптимальным путем но углубляться слишком сильно в оптимизацию на уровне кода смысла нет в большинстве случаев так как вы можете предсказать что конкретно будет является узким местом в системе

И для того что бы измерять эти показатели очень желательно ставить, особенно на первых порах пока вы не отправили в production свою систему, систему мониторинга такие как например newrelic rpm - это система которая позволяет вам сразу смотреть нагрузку, скорость запросов и выстраивать график самых медленных запросов, при этом можно посмотреть что в каждом конкретном запросе занимало большe всего времени, был ли это код, или запросы к базе данных, или это очень долго рендерилось view или еще какие либо проблемы к примеру внешние сервисы, и даже можно развернуть и посмотреть все sql запросы которые были сделаны во время запроса, таким образом понять и сделать для себя вывод стоит ли это оптимизировать или не стоит, это относится к тому что нужно сначала все измерять, но про оптимизацию мы поговорили обзорно и то что здесь перечислено далеко не все и тема очень большая

Кэширование это подстановка заранее вычисленного результата без необходимости делать его каждый раз, 

Виды кэширования

1) кэширование переменных(@var =|| Question.new) 
2) counter cache(Сразу же в таблице считает количество связанных моделей(связанных записей в подчиненной таблице что бы не обращаться к ней и ускорить таким образом запрос))
3) Кэширование View

 Сегодня поговорим про кэширование View, исторически в Rails их 3 вида

1. Page caching(исключено из Rails 4) кэширование страниц, этот вид доступен в виде gem, в первый раз когда запрашивается страница, генерируется ее Html, он сохраняется на диск и в последующие запросы наш front-end сервер к примеру nginx автоматически с диска отдает эту страницу даже не передавая запрос дальше в Rails, это может работать для статических страниц, к примеру если главная страница редко изменяется но поскольку rails это фреймворк для создания динамических страниц и статические страницы редко встречаются то кэшировать их чаще всего смысла нет потому что на них заходит очень малое количество людей  и это обычно не является главным препятствием которое стоит оптимизировать, поскольку запрос не доходит до Rails то не выполняются никакие редиректы и колбэки а отдается простой html

2. Action chaching(исключено из Rails 4) кэширование action, это работает почти так же как Page caching но тут уже запрос проходит через Rails, выполняются колбэки в контроллерах, выполняется сам  код в  action а ответ то есть сам вид, он закэширован полностью и отдается готовая с диска страница а код view не выполняется

3. Fragment chaching, фрагментарное кэширование, позволяет кэшировать не вид целиком а его отдельные части, отдельные фрагменты, то есть весь код выполняется и когда управление доходит до action то фрагмент который закэширован берется из кэша с диска а то что не закэшировано вычисляется и выполняется, то есть рендеринг выполняется быстрее так как некоторые части уже были вычислены и сохранены в кэше, хотя никто не мешает поместить весь view в такой кэш и тогда это будет примерно то же самое что и  Action chaching, практически один в один, это кстати одна из причин почему  Action chaching убран потому что его легко заменить при помощи  Fragment chaching, а Page caching исключен из Rails потому что очень редко он используется и он трудно управляем что в общем справедливо и для Action caching

 Fragment chaching работает так:

1. Ключ - значение: (у каждого закэшированного фрагмента есть ключ который указывает на этот фрагмент и значение а значение это и есть закэшированный html)
     1.1 Ключ - это строка(по умолчанию ключ это имя файла содержащий закэшированный к примеру html), то есть когда у нас рендерится некий вид в котором есть Fragment chaching то сначала вычисляется определенным образом ключ это кэша, он может либо вычисляться либо он может быть указан глобально мы можем прямо написать произвольную строчку, как то назвать этот кэш, и по этому названию(имени файла), берется содержимое файла и подставляется на место этого куска, в первый раз оно вычисляется и сохраняется в кэш, во второй раз он просто берет данные из кэш файла, в view мы помечаем некий фрагмент как закэшированный что бы он кэшировался, как это сделать рассмотрим позже

   Fragment chaching может хранится в разных хранилищах <img src="https://i.imgur.com/Vq9Zx6C.png" alt="Fragment caching" style="zoom:50%;" />

1. если хранить в памяти то это будет работать в development(так как используется один экземпляр приложения ) режиме а если в production у вас несколько инстансов приложения(экземпляров), в production обычно так и бывает то они не разделяют память между собой и у каждого экземпляра будет своя копия кэша
2. Хранить на диске медленнее чем в памяти но кэш могут использовать несколько экземплятов приложения и даже несколько серверов используя сетевое файловое хранилище настроенное между серверами, и эти сервера могут обращаться к одному и тому же кэшу, Хранит на диске не самый оптимальный способ так как это довольно медленно и забивает диск, кэш будет создаваться пока диск не заполнится ну или надо переодически удалять кэш с диска что тоже не очень удобно, способ получше это использовать Memcache

3. Memcache - это хранилище которое в памяти хранит ключ и значение, довольно давно используется и по умолчанию в Rails можно включить в качестве хранилища Memcache, плюс этого подхода в том что если у Memcache установлено ограничение в 20мб то если там больше кэшэй они начинают стираться, то есть у нас не накапливается мусор

4. И можно делать различные кастомные хранилища, например сейчас более популярен чем Memcache это redis что бы не тянуть еще одну зависимость если мы уже используем redis на сервере для других операций(active job), можно подключить другое хранилище из gem redis и у нас таким образом будет кэши хранится тоже в памяти но в redis

<img src="https://i.imgur.com/HITu0E8.png" alt="Russian-doll caching" style="zoom:33%;" />

Есть такое понятие как кэширование методом матрешки, как раз оно и относится к фрагментарному кэшированию и в последнее время используют это словосочетание, это ни какой то отдельный вид кэширования а это просто способ организации фрагментов
К примеру У нас есть Вопросы и когда мы заходим в вопрос у нас каждый вопрос содержит комментарии и ответы и ответ содержит тоже комментарии а так же есть файлы, мы можем поступить следующем образом, 1) полностью закэшировать все вопросы, ответы и комментарии 2) мы можем кэшировать ответы 3) закэшировать каждый комментарий к уже закэшированному вопросу, получается вложенный кэш
Это нужно что бы не рендерить снова не изменившийся части заново, к примеру мы к вопросу добавили новый ответ но все старые ответы и комментарии и само тело вопроса то сохранилось, если ли нам смысл перезагружать заново из базы все ответы с их комментариями, ответ нет так они не изменились, мы по сути добавляем один ответ а все остальные ответы мы можем взять из кэша

И появляется главная проблема под названием, Инвалидация кэша, как поддержать кэш в актуальном состоянии,  и порою это бывает очень сложно сделать, суть в том что например у нас есть вопрос закэшированный со списком ответов, мы добавили новый ответ к вопросу и тот файл что лежит на диске уже не актуальный потому что у нас добавлен новый ответ, нам нужно заново все прочитать из базы и положить в кэш до тех пор пока мы не добавим новый ответ это и есть инвалидациия а то есть пометка старого кэша как невалидного то есть устаревшего
Само устройство  Fragment chaching инвалидацию делает за нас, мы не должны практически о ней беспокоится 

<img src="https://i.imgur.com/ptpf6UL.png" alt="Инвалидация" style="zoom:33%;" />

Как только мы отредактируем вопрос или как то изменим поле ```updated_at``` у него изменилось  и как только оно изменилось у нас появился новый ключ а ключи они всегда вычисляются то есть когда мы делаем рендеринг вида то у нас в блоке который мы кэшируем сначала вычисляется ключ, он всегда вычисляется, мы вычисляем ключ на основе модели, и если у нас поле updated_at изменилось то у нас ключ будет иметь другое значение это означает что у нас и html который с этим ключом связан и лежит в кэше должен быть другой, то есть старый кэш станет инвалидированным и соответственно Rails видит что по новому ключу нет данных то данные заново рендеряться движком Rails и сохраняются в этот кэш по этому ключу, следующий раз если у нас если ключ опять совпадает то Rails берет из кэша, если ключ изменился то мы сначала пишем в кэш а в следующие разы уже читаем но если мы вернемся в ```Russian doll caching``` когда у нас кэши вложенные 
то здесь такой важный момент, если изменяется вложенный объект то он должен изменить поле updated_at у родителя, к примеру вопрос и ответы у него и комментарии у ответа, вот они сгенерированны и все записалось в кэш, потом мы набрали новый комментарий отправили и перезагрузили страницу, у нас в этот момент снова будет использоваться кэш всего вопроса, если добавление комментария к ответу не изменит кэш у вопроса то соответственно у нас будет так же самая старая страница без этого комментария, это легко можно исправить обновив поле updated_at у главного родителя то есть в данном случае у вопроса, если добавить к belongs_to опцию (touch: true), тогда это будет означать что как только изменяется объект то связанный с ним родительский объект у него тоже updated_at обновляется, то есть если мы добавляем комментарий у нас автоматический меняется updated_at у ответа и автоматически у вопроса  если мы правильно поставили touch: true, соответственно таким образом у нас кэш становится инвалидированным и у нас создается новый кэш уже с этим объектом, этот процесс может показаться нелогичным и тяжелой операцией что мы все вложенные в друг друга кэши инвалидируем и у нас заново все должно генерироваться, на самом деле инвалидация происходит только частично и большую часть объектов мы сможем прочитать из кэша, то есть у нас только часть изменяется, более подробно расписано ниже
И тут есть такая проблема то что генерирует такой подход много мусорных кэшей и при каждой инвалидации, старый кэш лежит мертвым грузом, можно их раз в сутки чистить, а если использовать к примеру не файловое хранилище и memcached или redis то можно настроить вообще то что бы они вообще не сохранялись на диск никогда и перезаписывались в течении какого либо времени, если заканчивается заданный лимит памяти, на memcached так можно сделать, то есть это не слишком большая проблема 



В Rails 4 добавили инвалидацию если изменилась верстка

<img src="https://i.imgur.com/N17Ct0s.png" alt="Cache Digest" style="zoom:33%;" />


если у нас изменился объект то у него будет новый ключ рассчитан и у него обновится кэш но если изменили мы не сам кэш а только верстку для него, к примеру выводились у нас комментарии в теги ```p``` а мы изменили на ```div``` то как сами данные не изменились а фрагмент уже закэширован то наши изменения не будут доступны, пока мы не удалим этот кэш либо что то еще не сделаем, то есть если данные не изменились и вычесляемый хэш остался старым то вернется тот же кэш и потому в Rails 4 хэш помимо названия модели,id, timestamp добавляется digest, ```digest``` это просто некая строка, если меняется верстка(вычисляется на основе верстки) то меняется и digest и старый хэш становится инвалидрованным.


