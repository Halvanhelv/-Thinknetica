Capistrano это инструмент автоматизации задач на сервере, используется для деплоя приложения и управление приложением и для выполнения разных задач, получение кода из репозитория для сервера, линковка конфигурационных файлов, выполнение миграций, для выполнения ```seeds.rb```,  и для множества задач.

Предоставляет ```DSL```  для описания сценария деплоя

Команды выполняются через ```ssh```

На сервере создается определенная структура папок для приложения

Можно откатить деплой если что то пошло не так, вызвав команду ```rollback```  и все откатиться до последней рабочей версии

Все команды капистрано выполняются локально даже если сценарии есть только на локальной машине, но рекомендуется все скрипты ```Capistrano ``` хранить так же на сервере и репозитории что бы другие разработчики могли делать деплой(если у них есть права для этого) и что бы скрипт всегда был рядом с проектом что бы не потерялся

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Структура папок ```Capistrano``` включает несколько папок и произвольная папка в которой находится весь проект(главная папка) и подпапки

```/releases``` копии кода приложения на каждый совершенный деплой, то есть при каждом деплое в папке ```/releases``` создается папка а качестве имени которой выступает время деплоя

```/current``` это символьная ссылка на последний релиз из папки ```/releases``` но только на успешный, то есть если деплой пройдет не успешно то под-папка в ```/releases```  создастся но папка ```current``` не создастся, а при каждом успешном деплое содержимое папки ```current``` будет ссылаться на последний успешный релиз из папки ```/releases``` и  благодаря такой системе папок можно легко откатиться на прошлый успешный релиз и содержимое папки ```current``` будет ссылаться(символьная ссылка) на предыдущий успешный релиз из папки ```/releases```, по умолчания капистрано хранит 5 последних релизов, на них можно откатываться но не всегда гладко, чаще всего по вине разработчиков, когда сам процесс отката не тестируется или не проводится, для важных приложений лучше всего тестировать это на отдельном стенде или сервере



```/shared``` содержит файлы и папки общие для всех релизов, к примеру конфиги базы данных

папка с картинками от юзеров ибо если так не делать то при каждом новом релизе старые файлы будут пропадать, ну и другие папки и файлы, может делать свои



```/repo``` содержит клонированный ```git``` репозиторий со всеми файлами приложения и ```git```, при релизе в него клонируется код и оттуда в папку ```/releases```

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Нужно добавить ```gem capistrano```  и некоторые другие так как Capistrano имеет модульную структуру и мы можем подключать дополнительные гемы или проще говоря дополнительные модули что бы добавить в капистрано дополнительные рецепты, то есть те задачи которые нам необходимо делать при деплое

Все изменения для Capistrano по умолчанию берутся из ветки master, если вы работаете в другой ветке то для начала вам нужно слить изменения в ветку master или указать нужную ветку в конфиге Capistrano,  на уровне конфига Capistrano позволяет делать деплой только с одной ветки(с нескольких веток брать код нельзя), можно сконфигурировать что бы динамически можно было указать ветку при деплое но чаще в этом нет нужды

Список гемов 

```gem capistrano, require: false``` , опция ```require``` указывает нужно ли использовать гем при старте самого приложения, указываем ```false``` поскольку он используется только для деплоя приложения, в самом приложении он не нужен

```gem capistrano-bundler, require: false```  это модуль для задач связанных с установкой гемов то есть bundle install с некоторыми опциями(написано ниже об этих опциях)

```gem capistrano-rails, require: false``` нужен для прекомпиляции ассетов(js, css и тп) или запуск миграций, то есть специфичные для Rails задачи

сам Capistrano очень универсальный проект и деплой можно делать не только для Rails и потому такая модульная структура

```gem capistrano-rvm, require: false```  что бы Ruby запускался через rvm(менеджер версий Ruby)

```gem capistrano-passenger, require: false``` что бы иметь возможность управлять сервером приложений passenger без необходимости заходить на сервер

Сначала нужно cгенерировать конфиг файлы для Capistrano командой cap install

и создадутся следующие файлы и папки

![Установка файлов Capistrano][cap install]





Основной файл ```config/deploy.rb```  содержит основной конфиг

Файл ```config/deploy/staging.rb``` прежде чем заливать все на главный сервер используется тестовый сервер и обычно он называется staging сервером, так настройки полностью такие же как на главном сервере но к нему доступ имеют обычно только разработчки, заказчики, тестировщики и бета тестеры а не конечные пользователи, делается все это для того что бы протестировать приложение в окружении как у основого сервера, часто создается дополнительная ветка(development к примеру) и если все правильно работает это сливается в master ветку, можно создавать и другие конфиги если у нас многоступенчетная система выкладки изменений, альфа сервер, бета сервер и другие

Файл ```config/deploy/staging.rb``` 

Файл Capfile это конфиг самого Capistrano где описываем, какие плагины, модули и гемы мы подключаем, на сам деплой он не влияет, он влиет на то что Capistrano как инструмент будет уметь делать

Мы должны в Capfile подключить те гемы что мы ставили выше, то есть сделать как то так 

![Capistrano require][Capistrano require]



В дерикторию ```lib/capistrano/tasks```  можно положить кастомные задачи для Capistrano, по сути Rake задачи, у файлов должно быть расширение Rake

Вернемся в deploy.rb в базовый конфиг

```set :application, "my_application_name" ``` имя для приложения

```set :repo_url "git@example,com:me/my_repo.rb"``` ссылка на репозиторий именно``` ssh```( и начинается c ```git...```) версия ссылки а не ```http```

```set :deploy_to "/var/www/my_app/name"``` путь на сервере где будет деплоится весь проект со всеми папками

```set :deploy_user "linux_server_user_name"``` имя системного пользователя от имени которого будет деплоится приложение

```append :linked_files,  "config/database.yml"``` общие файлы для всех релизов, к примеру этот файл будет лежать по адресу:

```"/linux_server_user_name/my_application_name/shared/config/database.yml"``` 

так же полезно если нужно хранить файлы которые не должны лежать в гит репозитории, к примеру ```shared/config/master.key```( папка ```config```  создастся сама но файл ```database.yml``` нужно создать самому)

```append :linked_dirs,  "log", "tmp/pids"``` общие папки  для всех релизов, то есть все будет писаться в общие папки, что бы между релизами все не терялось

Идем в файл  ```config/deploy/production.rb``` и настроим индивидуальные конфиги

Нужно указать на какие сервера делать деплой

У серверов могут быть различные роли к примеру:

```app``` сервер где находится приложение

```web``` сервер где находится прокси сервер, ```nginx/ apache```

```db``` сервер с базой данных

Это нужно что бы ```Capistrano``` знал на каких серверах какие задачи выполнять

Есть два варианта синтаксиса 



![Server syntax][]

![Role syntax][]

Если у нас сервер один и он выполняет несколько функций то удобнее первый синтаксис

Если у нас на каждую роль приходится несколько серверов то удобнее второй синтаксис

Указываем ```server "127.0.0.1", user: "linux_user_name", roles: %w{app db web}, primary: true```  опция ```primary``` указывает что этот сервер главный если их несколько, если есть несколько application серверов то например миграции не надо запускать на каждом сервере поскольку они все подключены к одной базе данных, мы запускаем миграции только на главном сервере, то есть нет необходимости накатывать одну и ту же миграцию дважды на одну базу данных

```set :rails_env, :production``` указываем в каком окружении запустить Rails приложение(production development test) или другое если такое создано в  папке ```config/enviroments```

Осталось сконфигурировать доступ по ssh, можно настроить каждый сервер по отдельности но в нашем проекте нам подойдут и глобальные опции(у нас только один сервер для всего)

![Ssh Settings][]



```ruby
set :ssh_options, {
keys: %w{/home/my_local_linux_name/.ssh/id_rsa}, #путь до ключей ssh на локальной машине
forward_agent: true, #позволяет использовать наши локальные ssh ключи на сервере что бы сервер мог обращаться к закрытому репозиторию  нужно настраивать
auth_methods: %w{publickey password},  #доступ к удаленному серверу, можно указать несколько вариантов, в первую очередь использоваться ssh ключ
port: 2222 # Если используется нестандартный порт
}
```

[Github ssh fast forwarding][Github ssh fast forwarding]

В терминале вводим ```cap --tasks или cap -T``` что бы посмотреть какие команды доступны для Capistrano

теперь нужно проверить что на сервере есть все нужные папки и доступ в репозиторию ```github``` и если папок нет то Capistrano их создаст

вводим  ```cap production deploy:check```   опцию production указываем что бы указать нужный нам вариант сервера(или другое название ```stage```(на какую ступень деплоить на ```production``` или на ```staging``` ) ), данные для деплоя будут браться из ```deploy/production.rb```

При вводе каждой команды ```Capistrano``` показывает подробные логи в терминале

теперь нужно создать общий для всех релизов файл database.yml в папке /shared на сервере 

заходим на сервер через ```ssh```

```$ ssh server_linux_user_name@127.0.0.1 -p 2222```

в домашней дериктории пользователя Capistrano создал папку с нашим проектом, заходим в /shared/config и через nano создадим файл database.yml

```yaml
production:
  adapter: postgres
  encoding: unicode
  database: qna_production
  username: postgres
  password: '123123123' лучше писать в ковычках так как пароль может содержать спец символы для yml файлов
  pool: 20  # позволяет держать подключение к базе данных открытым  n  количество раз, полезно что бы не подключаться постоянно, экономит ресурсы, подключением можно делиться только в рамках одного экземпляра Rails приложения, общее количество подключений по умолчанию ограничено до 100, если будет больше то база перестанет отвечать то база перестанет отвечать и скажет что нет доступных подключений (для unicorn не имеет смысла делать больше 1 пула так как один воркер выполняет только один запрос за раз, но у пумы у каждого воркера может быть несколько потоков и для каждого потока можно использовать пул)
```

снова запускаем  ```cap production deploy:check```

Мы забыли добавить ```master.key в /shared```

Мы не просто создадим файл а передадим его с локальной машиной с помощью команды ```scp -P 2222 config/master.key deployer@127.0.0.1:/home/deployer/qna/shared/config``` путь для удаленного сервера указываем абсолютный, ```scp``` работает для ```ssh```

файл скопирован

снова запускаем  ```cap production deploy:check```

Теперь все должно пройти



Делаем сам деплой командой ```cap production deploy```

Мы не будем видеть какие гемы ставятся поскольку из за ```cap production deploy``` идет тихая установка без подробней 

Модуль ```capistrano-bundler``` ставит гемы в папку  /shared  и только гемы из группы ```production``` в ```Gemile``` 

Если появилась ошибка связанная с ```mysql2```  то скорее всего для  ``` gem 'mysql2'```  который используется вместе с ```sphinx``` не хватает библиотек, ставим на удаленном сервере с помощью:

```sudo apt install libmysqlclient-dev```

снова вводим ```cap production deploy```

Если упала при компиляции ```assets``` то ставим ```gem mini_racer``` для прекомпиляции ассетов, так же причиной может стать то что на сервере node и yarn ставились через ```nvm``` так как в линуксе используется разные варианты окружения для разных юзеров( интерактивная и неинтерактивная ) и капистрано используется как раз таки неинтерактивную и там в переменных окружения нет путей до nvm, иначе говоря игнорит содержимое ```.bashrc``` где как раз и прописаны пути до ```nvm```, решением стало ставить ```node``` глобально, можно еще было костыльнуть и сделать символические ссылки на версию из ```nvm```

пушим в репозиторий и снова

снова вводим ```cap production deploy```

Если появилась ошибка ```PG::Connection: FATAL: Peer authentication failed for user "postgres"```

Мы на удаленном сервере подключаемся к ```postgres``` по паролю а ```postgres``` по умолчанию требует подключения от системного юзера без пароля

Это важно сделать поскольку к примеру ```sphinx``` не умеет подключаться в ```postgres``` без пароля

заходим на сервер так как нужно отредактировать конфигурационный файл ```postgres``` и выполняем:

```sudo nano /etc/postgresql/НОМЕР ВАШЕЙ ВЕРСИИ у postgres/main/pg_hba.conf```

![pg_hba.conf][]



Все меняет на ```md5``` и перезагружаем ```postgres```  ```sudo service postgres restart```

 Теперь нужно создать базу данных и проще всего ее создать через ```Rails```, заходим в последний релиз из папки ```/releases``` и пишем:

```bundle exec rails  RAILS_ENV=production db:create```  

``````bundle exec``` нужен что бы использовались наши гемы в папке нашего приложения



Снова пишем ```cap production deploy```  и теперь деплой должен пройти

Теперь ставим ```gem capistano-sidekiq```

и подключаем его в ```Capfile```

Начиная с 6 версии  ```sidekiq```  нужно проделать дополнительные манипуляции, [Sidekiq systemd][Sidekiq systemd], читать внимательно и прописать правильный пути в файле ```sidekiq.service```

Так же что бы ```sidekiq``` запускал все очереди а не только базовые требуется конфиг файл, создаем  ```config/sidekiq``` и пишем 

```yaml
:queues:
  - default
  - mailers
  - ваша очередь
```





Настроим ```Sphinx```, на сервере ```Sphinx``` должен быть запушен как демон

в  ```Capfile``` подключаем ```require "thinking_sphinx/capistrano"``

Нужно сделать в приложении конфиг для ```thinking_sphinx``` если его еще не делали(```cap production thinking_sphinx:configure```), и настроить постоянное обновление индекса базы внутри Sphinx

Можно привязать  индексирование к созданию новой сущности( Новый вопрос или ответ) внутри кода а мы сделаем переодическую индексацию с помощью гема whenever, пишем внутри файла ```schedule.rb```(Был создан ранее при настройке ```whenever```) следующий код(```Rake``` задача) :

```ruby
every 30.minutes do 
rake ts:index
end
```

Теперь индексируем ```Sphinx``` командой ```cap production thinking_sphinx:index``

Теперь все готово но иногда приходится запускать Rake(Rails задачи) задачи на сервере, правильно это делать из папки current на удаленном сервере с помощью 

```bundle exec rails RAILS_ENV=production db:create ``` а для запуска консоли ```bundle exec rails RAILS_ENV=production rails c``` Но через консоль данные в БД стоит менять на свой страх и риск, так как это уже сервер для конечного пользователя

Иногда нужно смотреть логи и поскольку это ```Production``` то приложение запушено в фоне, логи можно прочитать из файла ```log/production.log``` с помощью команды ```tail -f log/production.log ``` это команда ```Linux```, флаг ```-f``` значит что содержимое файла будет постоянно обновляться.




[Capistrano require]: https://i.imgur.com/aZy5QwN.png
[cap install]:  https://i.imgur.com/qx7ypBm.png
[Server syntax]: https://i.imgur.com/1z0HH2F.png
[Role syntax]: https://i.imgur.com/zEyV0Fy.png
[Ssh Settings]: https://i.imgur.com/NE9YnMl.png
[Github ssh fast forwarding]: https://developer.github.com/v3/guides/using-ssh-agent-forwarding/

[pg_hba.conf]: https://i.imgur.com/euLheoq.png
[Sidekiq systemd]: http://ilab.me/howto/run-sidekiq-6-using-systemd/